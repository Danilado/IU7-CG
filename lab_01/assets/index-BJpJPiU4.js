var T=Object.defineProperty;var k=(r,t,e)=>t in r?T(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e;var o=(r,t,e)=>(k(r,typeof t!="symbol"?t+"":t,e),e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const s of i)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function e(i){const s={};return i.integrity&&(s.integrity=i.integrity),i.referrerPolicy&&(s.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?s.credentials="include":i.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(i){if(i.ep)return;i.ep=!0;const s=e(i);fetch(i.href,s)}})();const C=1e-10;class b{constructor(t,e){o(this,"x");o(this,"y");this.x=t,this.y=e}toString(){return`(${this.x}, ${this.y})`}}function $(r,t){return Math.abs(r.x-t.x)<C&&Math.abs(r.y-t.y)<C}class I{constructor(t,e,n){o(this,"vertex1");o(this,"vertex2");o(this,"vertex3");this.vertex1=t,this.vertex2=e,this.vertex3=n}}class F{constructor(t,e){o(this,"center");o(this,"r");this.center=t,this.r=e}}class w{constructor(t,e){o(this,"p1");o(this,"p2");o(this,"k");o(this,"c");this.p1=t,this.p2=e,this.k=(e.y-t.y)/(e.x-t.x),this.c=t.y-this.k*t.x}pointOnLine(t){return p(this.p1,this.p2,t)}getYbyX(t){return Number.isFinite(this.k)?t*this.k+this.c:null}getXbyY(t){return this.k?(t-this.c)/this.k:null}isHorizontal(){return!this.k}isVertical(){return!Number.isFinite(this.k)}}function p(r,t,e){return Math.abs((e.y-r.y)*(t.x-r.x)-(t.y-r.y)*(e.x-r.x))<C}function q(r,t,e){return!p(r,t,e)}function O(r,t){return Math.atan2(t.y-r.y,t.x-r.x)}function g(r,t){let e=O(r,t);return e=Math.abs(e),e>=Math.PI/2-C&&(e=Math.PI-e),e<C?0:e}function P(r){return r*180/Math.PI}function f(r,t){return Math.round(r*Math.pow(10,t))/Math.pow(10,t)}const L=document.querySelector("#ixcenter"),M=document.querySelector("#iycenter"),E=document.querySelector("#iradius"),X=document.querySelector("#submit"),B=document.querySelector("#inewx"),R=document.querySelector("#inewy"),A=document.querySelector("#padd"),Y=document.querySelector("#clearall"),D=document.querySelector("#clearout"),H=document.querySelector(".footertext");class W{constructor(t){o(this,"node");this.node=t}write(t,e){this.node.innerHTML+=e+t.replace(/\n/,"<br />")+"<br />",this.scrollToBottom()}clear(){this.node.innerHTML=""}warn(t){}log(t){}error(t){this.write(t,"ERROR: ")}scrollToBottom(){this.node.scroll(0,this.node.scrollHeight)}}const l=new W(H);let v="#222222";const _=document.querySelector("canvas");_.width=Math.round(_.getBoundingClientRect().width);_.height=Math.round(_.getBoundingClientRect().height);const z=_.getContext("2d");class K{constructor(t){o(this,"context");o(this,"canvas_width");o(this,"canvas_height");o(this,"width");o(this,"height");o(this,"minx");o(this,"miny");o(this,"maxx");o(this,"maxy");o(this,"base");o(this,"aspect_ratio");o(this,"scale");this.canvas_width=_.width,this.canvas_height=_.height,this.context=t,this.width=this.canvas_width,this.height=this.canvas_height,this.minx=0,this.miny=0,this.maxx=this.width,this.maxy=this.height,this.base={x:0,y:-this.maxy},this.aspect_ratio=this.canvas_width/this.canvas_height,this.scale=1,this.context.textAlign="center",this.context.font="16px serif",this.context.beginPath(),this.context.lineWidth=1,this.context.fillStyle=v,this.context.strokeStyle=v}getCanvasCoords(t){return new b(this.base.x+(t.x-this.minx)*this.scale,-(this.base.y+(t.y-this.miny)*this.scale))}drawPoint(t,e){if(this.minx>t.x||this.maxx<t.x||this.miny>t.y||this.maxy<t.y)return null;let n=this.getCanvasCoords(t);n&&(this.context.beginPath(),this.context.arc(n.x,n.y,3,0,Math.PI*2),this.context.fill(),this.context.closePath(),this.context.beginPath(),this.context.fillText(e,n.x,n.y-10),this.context.closePath())}drawCircle(t){let e=this.getCanvasCoords(t.center);console.log(e),this.context.beginPath(),this.context.arc(e.x,e.y,t.r*this.scale,0,Math.PI*2),this.context.stroke(),this.context.closePath(),this.drawPoint(t.center,`C: ${t.center.toString()}`)}drawTriangle(t,e){let n=this.getCanvasCoords(t.vertex1),i=this.getCanvasCoords(t.vertex2),s=this.getCanvasCoords(t.vertex3);this.context.beginPath(),e&&(this.context.strokeStyle=e),this.context.moveTo(n.x,n.y),this.context.lineTo(i.x,i.y),this.context.lineTo(s.x,s.y),this.context.lineTo(n.x,n.y),this.context.stroke(),this.context.strokeStyle=v,this.context.closePath()}drawSegment(t,e,n){let i=this.getCanvasCoords(t),s=this.getCanvasCoords(e);this.context.beginPath(),n&&(this.context.strokeStyle=n),this.context.moveTo(i.x,i.y),this.context.lineTo(s.x,s.y),this.context.stroke(),this.context.strokeStyle=v,this.context.closePath()}drawLine(t,e){let n=new b(this.minx,0),i=new b(this.maxx,0);t.isHorizontal()?(n.y=t.p1.y,i.y=t.p1.y):t.isVertical()?(n.y=this.miny,i.y=this.maxy,n.x=t.p1.x,i.x=t.p1.x):(n.y=t.getYbyX(n.x),i.y=t.getYbyX(i.x)),this.drawSegment(n,i,e)}endFrame(){this.context.clearRect(0,0,this.canvas_width,this.canvas_height)}setBoundaries(t){let e=t.x_min,n=t.x_max,i=t.y_min,s=t.y_max,a=n-e,d=s-i;if(a/d<this.aspect_ratio){let c=d/a*this.aspect_ratio,y=a*c-a;n+=y/2,e-=y/2,a=a*c}else{let c=a/d/this.aspect_ratio,y=d*c-d;s+=y/2,i-=y/2,d=d*c}let m=this.canvas_width/a;this.minx=e,this.maxx=n,this.miny=i,this.maxy=s,this.scale=m,this.width=a,this.height=d,l.log(`Меняю масштаб и пределы. Текущий масштаб: ${f(this.scale,2)} пикс. к 1 ед координат`),l.log(`x: [${f(e,2)}; ${f(n,2)}]   y: [${f(i,2)}; ${f(s,2)}]`)}updateStrokeColor(){this.context.fillStyle=v,this.context.strokeStyle=v}}const u=new K(z);class V{constructor(){}findTrianglesIntersectingCircleCenter(t,e){if(t.length<3)return{rc:1};const n=[];for(let h=0;h<t.length-2;h++)for(let m=h+1;m<t.length-1;m++)for(let c=m+1;c<t.length;c++)q(t[h].pt,t[m].pt,t[c].pt)&&n.push([t[h],t[m],t[c]]);if(!n.length)return{rc:2};const i=n.filter(h=>this.triangleSideLineIntersectsPoint(h,e.center));if(!i.length)return{rc:3};const s=[];let a=this.triangleAngleWithXThroughPoint(i[0],e.center),d=0;return i.forEach((h,m)=>{let c=this.triangleAngleWithXThroughPoint(h,e.center);s.push(c),c<a&&(a=c,d=m)}),{rc:0,data:{triangles:i,angles:s,bestIndex:d}}}triangleSideLineIntersectsPoint(t,e){return p(t[0].pt,t[1].pt,e)||p(t[0].pt,t[2].pt,e)||p(t[1].pt,t[2].pt,e)}triangleAngleWithXThroughPoint(t,e){for(let n=0;n<3;++n)if($(t[n].pt,e))return this.triInterFindMinimal(t,t[n]);return p(t[0].pt,t[1].pt,e)?g(t[0].pt,t[1].pt):p(t[0].pt,t[2].pt,e)?g(t[0].pt,t[2].pt):g(t[1].pt,t[2].pt)}triInterFindMinimal(t,e){let n=t.filter(i=>i!==e);return Math.min(g(e.pt,n[0].pt),g(e.pt,n[1].pt))}getBoundaries(t,e){let n={x_min:0,x_max:0,y_min:0,y_max:0};n.x_min=e.center.x-e.r,n.x_max=e.center.x+e.r,n.y_min=e.center.y-e.r,n.y_max=e.center.y+e.r,t.forEach(a=>{n.x_min=Math.min(n.x_min,a.pt.x),n.x_max=Math.max(n.x_max,a.pt.x),n.y_min=Math.min(n.y_min,a.pt.y),n.y_max=Math.max(n.y_max,a.pt.y)});let i=n.x_max-n.x_min,s=n.y_max-n.y_min;return n.x_max+=.1*i,n.x_min-=.1*i,n.y_max+=.1*s,n.y_min-=.1*s,n}getIntersectingLine(t,e){for(let n=0;n<3;++n)if($(t[n].pt,e)){let i=t.filter(s=>s!==t[n]);return g(t[n].pt,i[0].pt)<g(t[n].pt,i[1].pt)?new w(t[n].pt,i[0].pt):new w(t[n].pt,i[1].pt)}return p(t[0].pt,t[1].pt,e)?new w(t[0].pt,t[1].pt):p(t[0].pt,t[2].pt,e)?new w(t[0].pt,t[2].pt):new w(t[1].pt,t[2].pt)}}const N=new V;class j{constructor(t){o(this,"pt");o(this,"node");o(this,"indexnode");o(this,"deletebutton");o(this,"coords");o(this,"index",-1);this.pt=t,this.node=document.createElement("div"),this.indexnode=document.createElement("input"),this.indexnode.disabled=!0,this.deletebutton=document.createElement("input"),this.coords=[],this.index=-1,this._initNode(),this._initIndex(),this._initDel(),this._initCoords(),this.form(),this.update(),this.addCoordListeners()}form(){this.node.appendChild(this.indexnode),this.coords.forEach(t=>{t.type="text",t.classList.add("coordedit"),this.node.appendChild(t)}),this.node.appendChild(this.deletebutton)}update(){this.indexnode.value=`${this.index+1}`,this.coords[0].value=`${this.pt.x}`,this.coords[1].value=`${this.pt.y}`}addCoordListeners(){this.coords[0].addEventListener("input",()=>{u.endFrame();let t=Number(this.coords[0].value);if(Number.isNaN(t)||!this.coords[0].value)return l.error(`Ошибка изменения координаты X точки ${this.index+1}`);this.pt.x=t,l.log(`Координата X точки ${this.index+1} изменена на ${t}`)}),this.coords[1].addEventListener("input",()=>{u.endFrame();let t=Number(this.coords[1].value);if(Number.isNaN(t)||!this.coords[1].value)return l.error(`Ошибка изменения координаты Y точки ${this.index+1}`);this.pt.y=t,l.log(`Координата Y точки ${this.index+1} изменена на ${t}`)})}addDelCallback(t){this.deletebutton.addEventListener("click",()=>{u.endFrame(),t()})}_initNode(){this.node.classList.add("row")}_initDel(){this.deletebutton.classList.add("button"),this.deletebutton.value="⨯",this.deletebutton.type="button"}_initIndex(){this.indexnode.type="button",this.indexnode.classList.add("button")}_initCoords(){this.coords.push(document.createElement("input")),this.coords.push(document.createElement("input"))}toString(){return`${this.index+1}: ${this.pt.toString()}`}}class G{constructor(t){o(this,"node");o(this,"pointarr");this.node=document.querySelector(t),this.pointarr=[]}add(t){let e=this.pointarr.length;this.pointarr.push(t),t.index=e,t.addDelCallback(()=>{this.remove(t)}),t.update(),this.update()}remove(t){u.endFrame(),l.log(`Удаляю точку ${t.index+1}`),this.node.removeChild(t.node),this.pointarr=this.pointarr.filter(e=>e!==t),l.log("Меняю нумерацию точек..."),this.pointarr.forEach((e,n)=>{e.index=n,e.update()})}update(){this.pointarr.forEach(t=>{t.update(),this.node.appendChild(t.node)})}clear(){u.endFrame(),this.pointarr.forEach(t=>{this.node.removeChild(t.node)}),this.pointarr=[],this.update()}}const S=new G(".points");A.addEventListener("click",()=>{u.endFrame();let r=B.value,t=R.value,e,n;if(e=Number(r),Number.isNaN(e)||!r)return l.error("Ошибка чтения значения X новой точки");if(n=Number(t),Number.isNaN(n)||!t)return l.error("Ошибка чтения значения Y новой точки");S.add(new j(new b(e,n)))});Y.addEventListener("click",()=>{u.endFrame(),S.clear()});X.addEventListener("click",()=>{u.endFrame();let r=Number(L.value);if(Number.isNaN(r)||!L.value)return l.error("Ошибка чтения значения координаты x центра окружности");let t=Number(M.value);if(Number.isNaN(t)||!M.value)return l.error("Ошибка чтения значения координаты y центра окружности");let e=Number(E.value);if(Number.isNaN(e)||!E.value)return l.error("Ошибка чтения значения радиуса окружности");let n=new F(new b(r,t),e),i=N.findTrianglesIntersectingCircleCenter(S.pointarr,n);if(i.rc){if(i.rc==1)return l.error("Недостаточно точек для построения даже одного треугольника");if(i.rc==2)return l.error("На этих точках не удалось построить ни одного треугольника");if(i.rc==3)return l.error("Нe нашлось ни одного треугольника, прямая проходящая через сторону которого пересекала бы центр окружности")}let s=i.data.triangles,a=i.data.angles,d=i.data.bestIndex,h=s[d];l.write(`ОТВЕТ:
Найденные треугольники:
`,"");for(let x=0;x<s.length;++x)l.write(`${x+1}: треугольник на точках ${s[x][0].index+1} ${s[x][0].pt.toString()}; ${s[x][1].index+1} ${s[x][1].pt.toString()}; ${s[x][2].index+1} ${s[x][2].pt.toString()}, угол с осью Абсцисс: ${f(P(a[x]),6)}град.`,"");l.write(`Треугольник с наименьшим углом к оси абсцисс:
${d+1}: ${h[0].index+1} ${h[0].pt.toString()}; ${h[1].index+1} ${h[1].pt.toString()}; ${h[2].index+1} ${h[2].pt.toString()}, угол с осью Абсцисс: ${f(P(a[d]),6)}град.`,"");let m=N.getBoundaries(h,n);u.setBoundaries(m),u.drawCircle(n);let c=new I(h[0].pt,h[1].pt,h[2].pt);u.drawTriangle(c,"blue");let y=N.getIntersectingLine(h,n.center);u.drawLine(y,"red"),S.pointarr.forEach(x=>{u.drawPoint(x.pt,x.toString())})});D.addEventListener("click",()=>{l.clear(),u.endFrame()});
